<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Javascript Engine and Execution Context | Vinoo</title>
<meta name="keywords" content="javascript, javascript-series">
<meta name="description" content="Let&#39;s study about the JS Engine and Execution Context in this article. Warning - we take a pretty deep dive into the concepts üîç">
<meta name="author" content="">
<link rel="canonical" href="http://vinoo.in/blog/javascript-engine-execution-context/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.ac1461f0cb2666fe70ac98eb224e3cb62eee25859826369600d0758e1a0c3596.css" integrity="sha256-rBRh8MsmZv5wrJjrIk48ti7uJYWYJjaWANB1jhoMNZY=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>

<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/atom-one-dark.min.css"
  integrity="sha512-Fcqyubi5qOvl+yCwSJ+r7lli+CO1eHXMaugsZrnxuU4DVpLYWXTVoHy55+mCb4VZpMgy7PBhV7IiymC0yu9tkQ=="
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
/>



<script async src="https://www.googletagmanager.com/gtag/js?id=G-KSYS2SPBZ9"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-KSYS2SPBZ9', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Javascript Engine and Execution Context" />
<meta property="og:description" content="Let&#39;s study about the JS Engine and Execution Context in this article. Warning - we take a pretty deep dive into the concepts üîç" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://vinoo.in/blog/javascript-engine-execution-context/" />
<meta property="og:image" content="http://vinoo.in/blog/javascript-engine-execution-context/3.png" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2023-09-15T21:36:56&#43;05:30" />
<meta property="article:modified_time" content="2023-09-15T21:36:56&#43;05:30" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://vinoo.in/blog/javascript-engine-execution-context/3.png" />
<meta name="twitter:title" content="Javascript Engine and Execution Context"/>
<meta name="twitter:description" content="Let&#39;s study about the JS Engine and Execution Context in this article. Warning - we take a pretty deep dive into the concepts üîç"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://vinoo.in/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Javascript Engine and Execution Context",
      "item": "http://vinoo.in/blog/javascript-engine-execution-context/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Javascript Engine and Execution Context",
  "name": "Javascript Engine and Execution Context",
  "description": "Let's study about the JS Engine and Execution Context in this article. Warning - we take a pretty deep dive into the concepts üîç",
  "keywords": [
    "javascript", "javascript-series"
  ],
  "articleBody": "JavaScript Engine A JavaScript engine is simply put - a program that executes JavaScript code. Each browser has its own JS engine. Firefox has SpiderMonkey, Microsoft Edge has Chakra, Opera has Caraken, etc. These are all customised JavaScript and WebAssembly implementations depending on the browser‚Äôs architecture. The most widely used is of course, Google Chrome browser and its engine is called V8.\nV8 is built mainly with C++, and it powers Chrome as well as NodeJS which is a JS runtime to build server-side applications.\nWhat does the JS Engine consist of? The JS Engine has two main components - a Call Stack and a Heap.\nThe Call Stack is where our gets executed using something called the Execution Context. The Heap is an unstructured memory pool which stores all the objects that our application needs. We will discuss this in detail soon below, but let‚Äôs rewind for a bit here.\nRemember in our previous post we had read that JavaScript is an interpreted language? Well, it is not 100% true since interpreted languages are much slower than compiled languages and modern applications cannot afford to be that slow. This is why the modern JS Engine now has a mix of compilation and interpretation - called Just-In-Time compilation.\nCompilation - The entire source code is converted to machine code once, and a binary file is created which contains this converted machine code; finally this file will be executed later by a computer. Compilation is done ‚Äúahead of time‚Äù.\nInterpretation - The source code is ‚Äúinterpreted‚Äù and executed line by line by the interpreter. In other words, compilation and execution are done sequentially, line by line. The downside is that multiple executions of the same source code will be interpreted again and again.\nNow that this above difference is clear, JIT is a bit easier to understand. The ahead-of-time compilation still exists, but no file exists to be executed. The execution happens immediately after compilation - which is perfect for JavaScript to do compilation and execution simultaneously rather than line-by-line interpretation.\nHow does the code get executed? As discussed before, our code first enters the JS engine to begin the process of execution.\nOnce the code enters the engine, it is parsed - which means the code is being read. This code is parsed into a data structure called the ‚ÄúAST‚Äù - Abstract Syntax Tree.\nThis AST is then compiled into machine code - and finally is executed immediately in the Call Stack.\nNow this is the most important piece of the puzzle - what is the Call Stack and where did it come from? To understand this, let‚Äôs start off with a diagram -\nMDN defines call stack like this - A call stack is a mechanism for an interpreter (like the JavaScript interpreter in a web browser) to keep track of its place in a script that calls multiple functions ‚Äî what function is currently being run and what functions are called from within that function, etc.\nEssentially, it is used to keep a record of all the execution contexts (more on this below) - global execution context, function execution context, etc - in an order which are then executed by the JS engine.\nConsider the following code -\nfunction calculate() { // random code // .. add() // some other code after add() function // .. } function add(a, b) { return a + b } calculate() Here, all the functions, both global and inner, are collected and put into the call stack in a certain order to be executed later on. If there are any Web APIs like fetch, timer, etc then they will be pushed into the call stack for execution only once the call stack is empty - meaning once all the functions within call stack are processed, only then will these API methods be pushed into the call stack. This is because these web APIs are not part of the native JS engine itself; rather, JS gets access to these APIs through the global window object. This process can be visualised like so -\nAll the callback functions that add and enhance interactivity to our web apps - onClick, setInterval, etc are first put into a data structure called the Callback Queue. And then, as mentioned before, once the Call Stack is empty, the callback functions are pushed to the Call Stack for execution.\nHow exactly do these callback functions get pushed to the Call Stack, and when does the Callback Queue know when to push?\nThat‚Äôs exactly where the Execution Context as a concept wins üòé Let‚Äôs see how it works, below.\nExecution Context Simply put, Execution Context is an environment created by the JS Engine when code begins executing. This environment is for top level code - variable and function declarations only. Take a look at the diagram below -\nAs you can see, the Execution Context here is named ‚ÄúGlobal Execution Context‚Äù (GEC) - which is what gets created by the JS Engine when the program is run for the first time.\nGEC has two sections - one for storing data (variables, functions, etc), and another for execution of the program (returning values). Now that we know what an Execution Context is, let‚Äôs understand how code is actually executed by the GEC.\nFollowing the creation of a Global Execution Context at the beginning of the program execution, the thread of execution of the code happens in two phases -\nDeclaration Phase Execution Phase Consider the following code -\nlet numOne = 21 function square(num) { return num * num } let result = square(numOne) let username = 'Arya' function greet() { return `Hello ${username}` } greet() Let us examine how this code gets executed phase by phase in the Execution Context. As soon as we run the program, the JS Engine creates a Global EC as we saw earlier.\nDeclaration Phase Once the GEC is created, we enter the Declaration Phase -\nNow, the first line of code - let numOne = 21 is a variable declaration. Note that declaration and assignment are two different things. let numOne is a variable declaration, while numeOne = 21 is a variable assignment. So, in the GEC, within the Memory, a variable with the name numOne is created with its value being currently undefined - since we are still in the declaration phase. The next line, function square(num) ... is also a function declaration which has an argument num - so, for all purposes, this function is a declaration of variable again. Again, in the memory, a function variable with the name square gets created with. Whatever is within the function block is ignored for now. Next, we have let result = square(numOne) which is a variable declaration since we are assigning the function call of square(numOne) to a variable called result. So, result gets stored in the Memory - again with the value undefined for now. Next up, we have the variable let username = 'Arya' - same as the above step. Lastly, we have the function declaration greet() - which gets created in the Memory. This entire process of Declaration Phase can be visualised through the illustration below -\nExecution Phaase Once the Declaration Phase is done, we enter into the Execution Phase. The execution context looks for all function executions like function calls, return statements, etc here. This is the thread of execution that follows for the above code -\nnumOne is assigned a value of 21, so in the Memory, the value of numOne changes from undefined to 21 function square(num is just a declaration so this block is skipped. Next up, we have the result variable being assigned a function call square(numOne) - this is where an important part of the Execution Context comes into picture. Every time the thread of execution encounters a function call, the Global Execution Context creates a separate environment - Function Execution Context (FEC). This means that an FEC is created for each function call in the code execution. And once the function execution is done - which is indicated by return statements - that particular FEC is deleted from the GEC.\nSo now, continuing the above thread of execution for the variable result -\nA separate FEC is created, with its own Memory and Execution sections. Again, this FEC block follows its own Declaration Phase and Execution Phase. result is assigned a function execution of square(numOne). Now, square was declared earlier with the argument num - this argument num is also considered a variable declaration for the function square. A declaration phase begins in the FEC created within the GEC for this particular function. num is stored in Memory with initial value undefined. No other declarations are available in square(numOne), so we enter into Execution Phase. Now in Execution Phase, we have the value for num as 21 from the GEC‚Äôs Memory; so the value for num changes from undefined to 21 here. The function square returns num * num so this is executed in the Execute section of the FEC. Since we have the value for num now, the value of 21 * 21 = 441 is calculated and returned. This returned value of 441 is now assigned to the variable result for which this separate FEC was started in the first place. Once this function is done executing, the FEC instance for square is deleted. Moving on from result now - we have the variable username which gets the value Arya assigned to it. Next, the function greet is already declared, so we skip this step. Finally, the greet function is called, which means another FEC is created within the GEC for this function. Within the FEC, we first go into declaration phase - but since there is no declarations in the function greet, we move on to the execution phase. The return statement here calls in the value of the variable username - which just got a value assigned to it above. So the statement Hello Arya is returned, which means the execution phase is done, which means the FEC for greet function is done, which means that the statement Hello Arya is returned to the GEC‚Äôs Memory, and this particular FEC instance is now deleted. THAT. WAS. EXHAUSTIVE.\nBut in a good way though ü§ì\nThese concepts can take some time, and repetition, to grasp a solid understanding of, but these are important to lay a solid foundation of how we write native JavaScript in various scenarios, and also helpful in debugging.\nIn the next post, let‚Äôs study about Scope and the Scope Chain - and why it is important to understand how it works.\nKeep shipping üöÄ\n",
  "wordCount" : "1779",
  "inLanguage": "en",
  "image":"http://vinoo.in/blog/javascript-engine-execution-context/3.png","datePublished": "2023-09-15T21:36:56+05:30",
  "dateModified": "2023-09-15T21:36:56+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://vinoo.in/blog/javascript-engine-execution-context/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Vinoo",
    "logo": {
      "@type": "ImageObject",
      "url": "http://vinoo.in/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">

<script async src="https://www.googletagmanager.com/gtag/js?id=G-KSYS2SPBZ9"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-KSYS2SPBZ9', { 'anonymize_ip': false });
}
</script>

<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header sticky-header">
    <nav class="nav">
        <div class="logo">
            <a href="http://vinoo.in/" accesskey="h" title="Vinoo (Alt + H)">Vinoo</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="http://vinoo.in/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://vinoo.in/blog" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="http://vinoo.in/projects" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="http://vinoo.in/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://vinoo.in/">Home</a>&nbsp;¬ª&nbsp;<a href="http://vinoo.in/blog/">Blogs</a></div>
    <h1 class="post-title">
      Javascript Engine and Execution Context
    </h1>
    <time style="font-size: 12px;">
      Sep 15, 2023
    </time>
    <div class="post-description">
      Let&#39;s study about the JS Engine and Execution Context in this article. Warning - we take a pretty deep dive into the concepts üîç
    </div>
    <div class="post-meta">



</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="http://vinoo.in/blog/javascript-engine-execution-context/3.png" alt="">
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">‚Äé Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#javascript-engine" aria-label="JavaScript Engine">JavaScript Engine</a><ul>
                        
                <li>
                    <a href="#what-does-the-js-engine-consist-of" aria-label="What does the JS Engine consist of?">What does the JS Engine consist of?</a></li>
                <li>
                    <a href="#how-does-the-code-get-executed" aria-label="How does the code get executed?">How does the code get executed?</a></li></ul>
                </li>
                <li>
                    <a href="#execution-context" aria-label="Execution Context">Execution Context</a><ul>
                        
                <li>
                    <a href="#declaration-phase" aria-label="Declaration Phase">Declaration Phase</a></li>
                <li>
                    <a href="#execution-phaase" aria-label="Execution Phaase">Execution Phaase</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="javascript-engine">JavaScript Engine<a hidden class="anchor" aria-hidden="true" href="#javascript-engine">#</a></h2>
<p>A JavaScript engine is simply put - a program that executes JavaScript code. Each browser has its own JS engine. Firefox has SpiderMonkey, Microsoft Edge has Chakra, Opera has Caraken, etc. These are all customised JavaScript and WebAssembly implementations depending on the browser&rsquo;s architecture. The most widely used is of course, Google Chrome browser and its engine is called V8.</p>
<p>V8 is built mainly with C++, and it powers Chrome as well as NodeJS which is a JS runtime to build server-side applications.</p>
<h3 id="what-does-the-js-engine-consist-of">What does the JS Engine consist of?<a hidden class="anchor" aria-hidden="true" href="#what-does-the-js-engine-consist-of">#</a></h3>
<p>The JS Engine has two main components - a Call Stack and a Heap.</p>
<p>The Call Stack is where our gets executed using something called the Execution Context. The Heap is an unstructured memory pool which stores all the objects that our application needs. We will discuss this in detail soon below, but let&rsquo;s rewind for a bit here.</p>
<p>Remember in our <a href="https://vinoo.hashnode.dev/javascript-under-the-hood-one">previous post</a> we had read that JavaScript is an interpreted language? Well, it is not 100% true since interpreted languages are much slower than compiled languages and modern applications cannot afford to be that slow. This is why the modern JS Engine now has a mix of compilation and interpretation - called Just-In-Time compilation.</p>
<blockquote>
<p>Compilation - The entire source code is converted to machine code once, and a binary file is created which contains this converted machine code; finally this file will be executed later by a computer. Compilation is done &ldquo;ahead of time&rdquo;.</p>
<p>Interpretation - The source code is &ldquo;interpreted&rdquo; and executed line by line by the interpreter. In other words, compilation and execution are done sequentially, line by line. The downside is that multiple executions of the same source code will be interpreted again and again.</p>
</blockquote>
<p>Now that this above difference is clear, JIT is a bit easier to understand. The ahead-of-time compilation still exists, but no file exists to be executed. The execution happens immediately after compilation - which is perfect for JavaScript to do compilation and execution simultaneously rather than line-by-line interpretation.</p>
<h3 id="how-does-the-code-get-executed">How does the code get executed?<a hidden class="anchor" aria-hidden="true" href="#how-does-the-code-get-executed">#</a></h3>
<p>As discussed before, our code first enters the JS engine to begin the process of execution.</p>
<p>Once the code enters the engine, it is <code>parsed</code> - which means the code is being read. This code is parsed into a data structure called the &ldquo;AST&rdquo; - Abstract Syntax Tree.</p>
<p>This AST is then <code>compiled</code> into machine code - and finally is <code>executed</code> immediately in the Call Stack.</p>
<p>Now this is the most important piece of the puzzle - what is the Call Stack and where did it come from? To understand this, let&rsquo;s start off with a diagram -</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694358438254/3b14df0e-6c9b-401c-b13d-074b38cf8bf1.png" alt=""  />
</p>
<p><mark>MDN defines call stack like </mark> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Call_stack"><mark>this</mark></a> <mark>- A </mark> <strong><mark>call stack</mark></strong> <mark>is a mechanism for an interpreter (like the JavaScript interpreter in a web browser) to keep track of its place in a script that calls multiple </mark> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Function"><mark>functions</mark></a> <mark>‚Äî what function is currently being run and what functions are called from within that function, etc.</mark></p>
<p>Essentially, it is used to keep a record of all the execution contexts (more on this below) - global execution context, function execution context, etc - in an order which are then executed by the JS engine.</p>
<p>Consider the following code -</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">calculate</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// random code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// ..
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">add</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// some other code after add() function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// ..
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">calculate</span>()
</span></span></code></pre></div><p>Here, all the functions, both global and inner, are collected and put into the call stack in a certain order to be executed later on. If there are any Web APIs like fetch, timer, etc then they will be pushed into the call stack for execution only once the call stack is empty - meaning once all the functions within call stack are processed, only then will these API methods be pushed into the call stack. This is because these web APIs are not part of the native JS engine itself; rather, JS gets access to these APIs through the global <code>window</code> object. This process can be visualised like so -</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694359277270/75dbeacc-3b60-4509-995b-a4cfaf4c6f81.png" alt=""  />
</p>
<p>All the callback functions that add and enhance interactivity to our web apps - <code>onClick</code>, <code>setInterval</code>, etc are first put into a data structure called the Callback Queue. And then, as mentioned before, once the Call Stack is empty, the callback functions are pushed to the Call Stack for execution.</p>
<p>How exactly do these callback functions get pushed to the Call Stack, and when does the Callback Queue know when to push?</p>
<p>That&rsquo;s exactly where the Execution Context as a concept wins üòé Let&rsquo;s see how it works, below.</p>
<h2 id="execution-context">Execution Context<a hidden class="anchor" aria-hidden="true" href="#execution-context">#</a></h2>
<p>Simply put, Execution Context is an environment created by the JS Engine when code begins executing. This environment is for top level code - variable and function declarations only. Take a look at the diagram below -</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694715595272/c4e38902-86e2-4967-a8d5-0ad586b986e9.png" alt=""  />
</p>
<p>As you can see, the Execution Context here is named &ldquo;Global Execution Context&rdquo; (GEC) - which is what gets created by the JS Engine when the program is run for the first time.</p>
<p>GEC has two sections - one for storing data (variables, functions, etc), and another for execution of the program (returning values). Now that we know what an Execution Context is, let&rsquo;s understand how code is actually executed by the GEC.</p>
<p>Following the creation of a Global Execution Context at the beginning of the program execution, the thread of execution of the code happens in two phases -</p>
<ol>
<li>Declaration Phase</li>
<li>Execution Phase</li>
</ol>
<p>Consider the following code -</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">numOne</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">num</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">num</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">numOne</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">username</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Arya&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">greet</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`Hello </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">username</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">greet</span>()
</span></span></code></pre></div><p>Let us examine how this code gets executed phase by phase in the Execution Context. As soon as we run the program, the JS Engine creates a Global EC as we saw earlier.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694714750225/889c67ee-ff2b-44d9-b34f-8a99f5d0f7bc.png" alt=""  />
</p>
<h3 id="declaration-phase">Declaration Phase<a hidden class="anchor" aria-hidden="true" href="#declaration-phase">#</a></h3>
<p>Once the GEC is created, we enter the Declaration Phase -</p>
<ul>
<li>Now, the first line of code - <code>let numOne = 21</code> is a variable declaration. Note that declaration and assignment are two different things. <code>let numOne</code> is a variable declaration, while <code>numeOne = 21</code> is a variable assignment. So, in the GEC, within the Memory, a variable with the name <code>numOne</code> is created with its value being currently <code>undefined</code> - since we are still in the declaration phase.</li>
<li>The next line, <code>function square(num) ...</code> is also a function declaration which has an argument <code>num</code> - so, for all purposes, this function is a declaration of variable again. Again, in the memory, a function variable with the name <code>square</code> gets created with. Whatever is within the function block is ignored for now.</li>
<li>Next, we have <code>let result = square(numOne)</code> which is a variable declaration since we are assigning the function call of <code>square(numOne)</code> to a variable called <code>result</code>. So, <code>result</code> gets stored in the Memory - again with the value <code>undefined</code> for now.</li>
<li>Next up, we have the variable <code>let username = 'Arya'</code> - same as the above step.</li>
<li>Lastly, we have the function declaration <code>greet()</code> - which gets created in the Memory.</li>
</ul>
<p>This entire process of Declaration Phase can be visualised through the illustration below -</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694716607362/868d2ba3-7d3c-43e2-ae6c-b1af17b60e0b.png" alt=""  />
</p>
<h3 id="execution-phaase">Execution Phaase<a hidden class="anchor" aria-hidden="true" href="#execution-phaase">#</a></h3>
<p>Once the Declaration Phase is done, we enter into the Execution Phase. The execution context looks for all function executions like function calls, return statements, etc here. This is the thread of execution that follows for the above code -</p>
<ul>
<li><code>numOne</code> is assigned a value of 21, so in the Memory, the value of <code>numOne</code> changes from <code>undefined</code> to <code>21</code></li>
<li><code>function square(num</code> is just a declaration so this block is skipped.</li>
<li>Next up, we have the <code>result</code> variable being assigned a function call <code>square(numOne)</code> - this is where an important part of the Execution Context comes into picture.</li>
</ul>
<p><mark>Every time the thread of execution encounters a function call, the Global Execution Context creates a separate environment - Function Execution Context (FEC).</mark> This means that an FEC is created for each function call in the code execution. And once the function execution is done - which is indicated by return statements - that particular FEC is deleted from the GEC.</p>
<p>So now, continuing the above thread of execution for the variable <code>result</code> -</p>
<ul>
<li>A separate FEC is created, with its own Memory and Execution sections. Again, this FEC block follows its own Declaration Phase and Execution Phase.
<ul>
<li><code>result</code> is assigned a function execution of <code>square(numOne).</code></li>
<li>Now, <code>square</code> was declared earlier with the argument <code>num</code> - this argument <code>num</code> is also considered a variable declaration for the function <code>square</code>.</li>
<li>A declaration phase begins in the FEC created within the GEC for this particular function.</li>
<li><code>num</code> is stored in Memory with initial value undefined.
<img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694718753829/065f8837-28e3-451b-b0c6-09b576c36281.png" alt=""  />
</li>
<li>No other declarations are available in <code>square(numOne)</code>, so we enter into Execution Phase.</li>
<li>Now in Execution Phase, we have the value for <code>num</code> as 21 from the GEC&rsquo;s Memory; so the value for <code>num</code> changes from <code>undefined</code> to 21 here.</li>
<li>The function <code>square</code> returns <code>num * num</code> so this is executed in the Execute section of the FEC. Since we have the value for <code>num</code> now, the value of <code>21 * 21 = 441</code> is calculated and returned.</li>
<li>This returned value of <code>441</code> is now assigned to the variable <code>result</code> for which this separate FEC was started in the first place.</li>
<li>Once this function is done executing, the FEC instance for <code>square</code> is deleted.
<img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694719108839/09667a6a-d895-4318-b843-a9f0cd4c4bf4.png" alt=""  />
</li>
</ul>
</li>
<li>Moving on from <code>result</code> now - we have the variable <code>username</code> which gets the value <code>Arya</code> assigned to it.</li>
<li>Next, the function <code>greet</code> is already declared, so we skip this step.</li>
<li>Finally, the <code>greet</code> function is called, which means another FEC is created within the GEC for this function.
<ul>
<li>Within the FEC, we first go into declaration phase - but since there is no declarations in the function <code>greet</code>, we move on to the execution phase.</li>
<li>The return statement here calls in the value of the variable <code>username</code> - which just got a value assigned to it above.</li>
<li>So the statement <code>Hello Arya</code> is returned, which means the execution phase is done, which means the FEC for <code>greet</code> function is done, which means that the statement <code>Hello Arya</code> is returned to the GEC&rsquo;s Memory, and this particular FEC instance is now deleted.
<img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1694719927468/4ad3b013-f35f-42d0-bf46-6ca4188d5938.png" alt=""  />
</li>
</ul>
</li>
</ul>
<hr>
<p>THAT. WAS. EXHAUSTIVE.</p>
<p><img loading="lazy" src="https://media4.giphy.com/media/zm0wMAolIdDvG/giphy.gif?cid=ecf05e47virolmkq5tg0ktc79bwltm76784kiuchkx232fxk&amp;ep=v1_gifs_search&amp;rid=giphy.gif&amp;ct=g" alt="Joey Tribbiani Friends GIF"  />
</p>
<p>But in a good way though ü§ì</p>
<p>These concepts can take some time, and repetition, to grasp a solid understanding of, but these are important to lay a solid foundation of how we write native JavaScript in various scenarios, and also helpful in debugging.</p>
<p>In the next post, let&rsquo;s study about Scope and the Scope Chain - and why it is important to understand how it works.</p>
<p>Keep shipping üöÄ</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://vinoo.in/tags/javascript/">javascript</a></li>
      <li><a href="http://vinoo.in/tags/javascript-series/">javascript-series</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="http://vinoo.in/">Vinoo</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
