[{"content":"In simple terms, Destructuring is an ES6 feature that helps us unpack values from an array or object into separate variables.\nWe use destructuring to break a complex data structure down into a smaller data structure like a single dimensional array or a variable.\nWhat is Array Destructuring? Array destructuring is a process of extracting values from complex array data structures. Destructuring does not mutate the original array and helps us perform multiple such destructuring operators\nFor arrays, we use destructuring to retrieve elements from the array and store them into variables.\nWhy do we need array destructuring? Let us look at a practical example -\nconst arr = [2, 3, 4] const a = arr[0] const b = arr[1] const c = arr[2] Notice how we had to individually create a single variable and assign each array value to this variable. Cumbersome right?\nWith destructuring, the process becomes VERY simple -\nconst [a, b, c] = [2, 3, 4] console.log(a, b, c) // 2, 3, 4 Note that the original array is not changed in any way.\nOne more thing to observe in the above example is that since the array values are in a sequential order, destructuring them into variables is quite straightforward. As in, a will be automatically assigned 2, b = 3, and c = 4 without having to explicitly state it.\nBut what if there are values somewhere further ahead in the array and we need to skip a few values to access it and assign it to a variable?\nThere is a quirky yet helpful way to do this.\nTake this example where we want to assign a fruit to an individual. Richard should be assigned banana but the desired fruit for Bighetti - kiwi - is further ahead in the array.\nconst fruits = [\u0026#39;banana\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;kiwi\u0026#39;] This is how we do it -\nconst [Richard, , , Bighetti] = fruits console.log(Richard, Bighetti) We simply put \u0026ldquo;gaps\u0026rdquo; during destructuring after the single comma operator , - which signifies that we intend to skip the values for that particular value. So, apple and orange are skipped and the variable Bighetti is assigned the value of kiwi.\nHow to swap values using destructuring? Swapping values is really easy with array destructuring. No more temp variables to be used! Although, if we want to perform more operations on the swapped values later on, we may need to assign them to a variable.\nSwapping is as simple as -\n[Richard, Bighetti] = [Bighetti, Richard] There we go. Previously assigned values of banana and kiwi to Richard and Bighetti are now swapped.\nHow to destructure nested arrays? The examples we saw above were for linear arrays or \u0026ldquo;shallow\u0026rdquo; arrays. What about destructuring a nested array? Arrays within arrays are a common data structure in real-life codebases. Consider the example -\nconst nested = [1, [2, 3, 4]] const [i, j] = nested console.log(i, j) The console statement would this -\nAs you can see, the value for i is 1 whereas the value for j is an array of values - 2, 3, 4. What if we want to return this array of values for j as a \u0026ldquo;flattened\u0026rdquo; array - as in, the values would be destructured again? Here is how we do that -\nconst nested = [1, [2, 3, 4]] const [i, [j, k, l]] = nested console.log(i, j, k, l) And this will return the values as expected -\nDestructuring with default values Many times, we may not know the exact size/length of the array we are dealing with, and while destructuring, we might try to assign non-existent values to variables. Consider this example -\nconst [p, q, r] = [8, 9] console.log(p, q, r) While the values for p and q would be displayed as 8 and 9, the value for r is returned to be undefined. As evident, a value for r does not exist in the array we are trying to destructure since it only contains two elements, so naturally it returns undefined, which is not something we want to deal with while working with large applications since returning undefined might break the flow of execution.\nIn such cases, simply specifying a default value to fall back into, can resolve the situation -\nconst [p, q, r = 1] = [8, 9] console.log(p, q, r) We can even set default values for all the variables if the array we are working with is dynamic and we are not sure of its values being generated properly.\nThere are multiple other ways to deal with this situation, especially with libraries like React where we perform a conditional render based on a value\u0026rsquo;s existence or similar conditional check.\nDestructuring is great on many levels due to its simplicity with the use of assignment operator = to extract values and immediately assign them to variables.\nAs mentioned, destructuring in no way changes the original array; instead it simply helps us assign its elements as values to other variables.\nIn the next post, we will look at destructuring for Objects, the most used data structure in JavaScript.\nKeep shipping ðŸš€\n","permalink":"http://vinoo.in/blog/destructuring-in-js-arrays/","summary":"In simple terms, Destructuring is an ES6 feature that helps us unpack values from an array or object into separate variables.\nWe use destructuring to break a complex data structure down into a smaller data structure like a single dimensional array or a variable.\nWhat is Array Destructuring? Array destructuring is a process of extracting values from complex array data structures. Destructuring does not mutate the original array and helps us perform multiple such destructuring operators","title":"Destructuring in JavaScript: Arrays"},{"content":"Intro Simply put, this is a special variable that is created for every Execution Context.\nOnce this has been created for the Execution Context (EC), it becomes a \u0026ldquo;keyword\u0026rdquo;. Then, it points to (or takes the value of) the parent of whatever function has used this. The interesting thing about this is that it behaves differently with respect to how it is used and called in different use cases. Let us see them one by one.\nDifferent scenarios of \u0026rsquo;this\u0026rsquo; - #1: Default Binding A simple program that has nothing but this statement - console.log(this) - will show that this will point to the global window object, like so -\n#2: Implicit Binding \u0026rsquo;this\u0026rsquo; in a method A method is any function that is defined inside an object.\nIn the example below, this will point to the parent object of the method that calls this. Since getCurrentYear is the method that calls this, the value of this will now point to the parent object - details. Hence, this.futureYear is equal to typing details.futureYear.\nconst details = { name: \u0026#39;Vinoo\u0026#39;, futureYear: 2049, getCurrentYear: function () { console.log(2199 - this.futureYear) console.log(this) } } details.getCurrentYear() // 150 As we can see, we get the result 150 when the function is called. The value for futureYear was accessed through the this variable. The value of this itself is the details object -\n\u0026rsquo;this\u0026rsquo; in a function call In a regular function call with strict mode enabled, this will return undefined ðŸ‘‡\nOtherwise, this will point to the global window object ðŸ‘‡\n\u0026rsquo;this\u0026rsquo; in Arrow Functions In arrow functions, this simply points to the this of its surrounding function - which means this points to the lexical scope/parent scope. This goes to say that arrow functions do not get their own this.\nExample -\n#3: Explicit Binding As the name suggests, explicit binding is a way to explicitly bind the value of this to a specific object. There are 3 ways to do this -\ncall() - Let\u0026rsquo;s say that our function is outside the object, and we still want this in the function to point to the object. We can do that as follows -\nHere, we are \u0026ldquo;binding\u0026rdquo; the object details to the function displayName() so that the this variable in that function can point to the desired object. If we DO NOT use the \u0026ldquo;call\u0026rdquo; binding, then as usual, this will simply point to the global window object.\nNow, what if we have multiple arguments to be passed? Look at the example below -\ncall() successfully binds the details we have passed to the person object and then the elements of the hobbies array, individually. But this is not the most efficient to bind things, is it? This is where the apply() method helps us.\napply() - this method works exactly like call() except that we can pass the array variable itself as a parameter instead of the array elements individually. Everything else stays the same -\nbind() - this method too, is almost no different from the call() or apply() methods but there is an important advantage to using it. First, let\u0026rsquo;s look at an example -\nNotice how we assigned the bind() method to a variable foo and then called it as a function? This is because bind() returns a new function that we can then invoke anywhere we wish. Now for the advantage bit - foo does not even get instantiated anywhere, does not have a reference, nothing. Even though the person object does not have a property named foo, we can still explicitly bind foo to person much later in the program such that person will now recognise foo as its own method.\n#4: \u0026rsquo;new\u0026rsquo; Binding new is yet another special keyword that is exclusively used in the case of constructor functions. These are used to create new objects. Let\u0026rsquo;s look at this example -\nlet Wizard = function(name, spell) { this.name = name this.spell = spell this.castMagic = function() { console.log(this.name + \u0026#39; has cast this spell - \u0026#39; + this.spell) } } let hermione = new Wizard(\u0026#39;Hermione\u0026#39;, \u0026#39;Occulus Reparo\u0026#39;) let ron = new Wizard(\u0026#39;Ron\u0026#39;, \u0026#39;Sunshine Daisies\u0026#39;) new is used to denote that we are creating a new object (instantiating) for the Wizard function. Note that Wizard is capitalised when we use new - a simple convention to differentiate, and also specify that this variable will always point to the empty object created by new. This is how we can get new instances easily for the same function with different arguments. Just simple Object Oriented Programming in action ðŸ˜Ž\nWe will study more about constructors and classes in depth in a later post.\n#5: HTML Event Element Binding - \u0026rsquo;this\u0026rsquo; in Event Listeners In case of event listeners, this points to the DOM element that the handler is attached to. Example -\nsendBtn.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(2 + 3) console.log(\u0026#39;Value of this - \u0026#39;, this) }) Here, on clicking the button \u0026lsquo;Send\u0026rsquo;, the value of this will indeed be the DOM element button that the function/handler is attached to.\nNOTE - if this function/handler is an arrow function, then the value of this again defaults to the global window object, like so -\nsendBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { console.log(2 + 3) console.log(\u0026#39;Value of this - \u0026#39;, this) }) Closing Notes That was it for this!\nWe will study more about how this is important for classes, constructors, and object oriented programming in the later posts.\nUntil the next one!\nKeep shipping ðŸš€\n","permalink":"http://vinoo.in/blog/this-in-javascript/","summary":"Intro Simply put, this is a special variable that is created for every Execution Context.\nOnce this has been created for the Execution Context (EC), it becomes a \u0026ldquo;keyword\u0026rdquo;. Then, it points to (or takes the value of) the parent of whatever function has used this. The interesting thing about this is that it behaves differently with respect to how it is used and called in different use cases. Let us see them one by one.","title":"this In Javascript - Simplified"},{"content":"Introduction Earlier, when we talked about the JS Engine, we saw there were two important parts that make up the processing engine -\nBoth the Call Stack and Heap are data structures that are used to store different types of variables. We have already seen the working of the Call Stack in our previous post.\nIn this post, let\u0026rsquo;s discuss the Heap memory and what role it plays in memory allocation for different data types in JavaScript.\nPrimitives vs Reference Types Consider the example below -\nExample 1 -\nHere, we see that the developer variable had the value of \u0026lsquo;Vinoo\u0026rsquo; and then we changed it to be \u0026lsquo;Robot\u0026rsquo;, and that is what is reflected in the console. The newDeveloper value, which was assigned the value of developer retains the original value even after we changed the original one.\nNow consider the below example -\nExample 2 -\nWhat we did here was to create an object emp with a few details, and then created another variable newEmp where we essentially copied (assigned) the values of emp to newEmp. And when we changed the value of the age property in newEmp, its value in the original object also got changed.\nWhy? And how?\nMemory Allocation in JavaScript Primitive types - number, string, boolean, undefined, null, and Reference types - Object literals, Arrays, Functions, etc are called so respectively because of the difference in the way memory is allocated for these types.\nPrimitive Types - Primitive types are, well, primitive in nature in the sense that memory is allocated directly to the variables. The Call Stack data structure is where these Primitive values are stored.\nIn Example 1 above, the variables developer and newDeveloper both get assigned specific addresses in memory, which is why when we change the value of one variable, it does not affect the value of another. Take a look at the illustration below -\nWhen we create the variable developer, it gets allocated a specific address (say 1010) in the memory - the Call Stack - and then the value \u0026lsquo;Vinoo\u0026rsquo; will be stored at this address. developer will actually now point to the address and not the value. Next, when we declare newDeveloper to be equal to developer, what happens is that newDeveloper will not be allocated a new address; instead, it will point to the same memory address as developer. And since the address holds the value Vinoo, the same will reflect when we print the value of newDeveloper to the console.\nWhat happened when we change the value of developer to \u0026lsquo;Robot\u0026rsquo;? The value at the address 1010 certainly does not get changed. Values stored in the Call Stack memory addresses are immutable in nature - so the address and the value remain unchanged. However, when we change the value of the developer, a new address is created with the new value, and the identifier developer will now point to the new address, while the newDeveloper identifier will still point to the earlier address and value. Like so -\nReference Types - In Example 2 above, we saw how changing the value of one property in the new copied object changed the value for the original object\u0026rsquo;s property as well. This is because Reference Types are stored in the Heap memory data structure and not the Call Stack directly. The below illustration throws some light -\nAs we can see, the properties of the emp object are first allocated an address in the Heap memory. The emp identifier is stored in the Call Stack under an address whose value references the address of the properties stored in Heap memory. So essentially, the value of the address of emp in Call Stack is simply a reference to the Heap memory\u0026rsquo;s address which in turn contains the actual values.\nNow, when we declare a new variable newEmp to be equal to emp, the new object just points to the address of the original object, and thereby its values. So when we change the value in the new object, it changes the original values too.\nThis behaviour is because the new variable newEmp is not really a new object itself; instead, it just points to the value of the address held by the original object, so technically, mutating one of them will mutate the other one too.\nHow to actually copy objects? There are multiple ways to do that, and it deserves a comprehensive post of its own, but for the scope of this post, we will look at one of the most basic and common methods - the Object.assign() method. Let\u0026rsquo;s see an example -\nAs we can see here, we used the Object.assign() method to assign the newEmp variable to be an object populated with the values of emp object.\nOnce that was done, we mutated the new object with an additional property yoe - and the original object remained unchanged.\nThis works well for a single level cloning - or shallow clone - of objects; meaning, that the Obejct.assign() method does not work completely on multiple/deeply nested objects. For example -\nAs can be seen, even though we only pushed the new item python to the languages array in the newEmp object, the original emp array also got mutated. This is because the array elements are considered to be deeply nested values and Object.assign() method will not be able to do the so called \u0026ldquo;deep cloning\u0026rdquo;.\nClosing Notes We will cover more on shallow clones and deep clones in detail in a later post. But for now, this post has covered enough to understand how memory allocation works in JavaScript.\nConfusing? Well, hang in there ðŸ¥²\nSee you in the next one!\nKeep shipping ðŸš€\n","permalink":"http://vinoo.in/blog/primitives-objects-memory-allocation/","summary":"Introduction Earlier, when we talked about the JS Engine, we saw there were two important parts that make up the processing engine -\nBoth the Call Stack and Heap are data structures that are used to store different types of variables. We have already seen the working of the Call Stack in our previous post.\nIn this post, let\u0026rsquo;s discuss the Heap memory and what role it plays in memory allocation for different data types in JavaScript.","title":"Primitives vs Objects: Memory Allocation In JavaScript"},{"content":"Before we define Hoisting, you should know that we have already seen Hoisting in action in our previous article and code snippets, and you would probably be writing code every day that implements Hoisting without consciously being aware of it! It is a very tricky concept, one that is simple enough in practice but takes some time to wrap our heads around, given the idiosyncrasies of JavaScript ðŸ˜ƒ\nLet\u0026rsquo;s do a quick recap by examining the code below -\nAs we know from our previous post on Execution Context, we have two phases of code execution - Declaration Phase and Execution Phase. According to that flow -\nIn line 1 of above code, console.log() is a function call with the variable username - and since it is a function call, it will be skipped, and the Execution Context goes to line 2, where variable sum is assigned the result of the function call add(2,3) . So within the Memory of the Global Execution Context, the variable sum is instantiated, with the initial value being undefined\nNext, we have the function add(numA, numB) - so add is defined in the Memory, but it is not undefined like a variable is. Instead, in the Declaration Phase, variable declaration and function declaration are different in this manner. Variables are initiated with the initial value undefined whereas function variables like add() in the above code, are initiated as functions - the Execution Context knows that function variables need to be initiated as functions.\nMoving on to line 6, username is a variable that gets initiated with undefined again.\nLine 7 again has the console.log() function that calls username variable, so it is skipped for now.\nFinally in line 8, we have a function call add(10,12) that is skipped for the Declaration Phase.\nThe execution flow changes from Declaration to Execution phase, and now the flow is like this -\nSince line 1 is a function call for console.log(), a Function Execution Context is created for console.log(). The value for username is not found in this execution context, so it bubbles out to find it in the parent memory, which is Global EC. Here, the value is found to be undefined and so the console.log() outputs it as such. The Function EC for console.log() is then deleted.\nMoving on, now the variable sum looks for its value - which is the return value of the function add(2, 3). As usual, a function execution context (EC) gets created for add(). How? Because earlier, we saw that function variables are initiated as functions in the declaration phase, unlike normal variables which get initiated as undefined. Now in the Declaration phase for this particular EC for add(2,3), it immediately knows that add() is a function. And they have the variables numA and numB - both of which get initiated as undefined. Now that declaration phase is over, execution phase begins, and both numA and numB get the values 2 and 3 respectively - since those are what the arguments are during the function call. It performs that return statement which 2 + 3 - the result 5 is finally stored as the value for the variable sum in the GEC\u0026rsquo;s memory and this FEC gets deleted immediately.\nNext, in line 6, the variable username is assigned the value \u0026lsquo;bifrost\u0026rsquo;, so its previous value of undefined changes to bifrost now.\nIn line 7, the console.log(username) function has the value for username, so it logs bifrost to the console.\nFinally in line 8, add(10,12) will return the relevant value since the function has already been declared before, and only the variable values are changed now - previously they were 2 and 3, now they are 10 and 12.\nObserve something very crucial here - in line numbers 1 and 2, we are calling a variable and a function that have not even been declared yet. And still, we do not run into errors. How? This is possible due to Hoisting.\nWhat is Hoisting? As the word suggests, it is a concept where variables and functions are \u0026ldquo;hoisted\u0026rdquo; up in the flow of execution so that they can be called/invoked even before they are actually declared. And as mentioned earlier, it is not a new concept again, but an existing one which we have already defined and seen in practice - the Declaration Phase in Execution Context.\nBecause of this Declaration Phase where variables and functions are initiated with their respective values (variables as undefined and function variables as functions), the JavaScript engine knows that these values already exist, and hence does not throw any error.\nThat is it. That is all Hoisting is.\nProof? Here you go -\nIn the snippet below, notice how, the console.log() for line number 1 already logs a statement with the value undefined.\nBy the time the flow is deeper into the code, and we arrive at line number 8, username now has the value assigned as bifrost and hence displays the same instead of undefined.\nNotice how for the variable assignment sum - which is a function call of add() - it does not throw an error that the variable/function is not defined. Instead, since EC already knows that sum is a function variable, it waits for the function declaration also to happen later on, and then returns the value to be assigned to sum and then logs it to the console.\nIn practice, this is how the variables are hoisted by the JS Engine -\nLines 13 - 17 represent declaration phase and lines 19 - 22 represent execution phase.\nBut.. we aren\u0026rsquo;t done yet Notice how the variable username was declared with var throughout our previous article and this one too - and it was intentional, because there is a subtle difference in how var, let, and const create variables.\nThe entire premise of using modern ES6 syntax to write our web applications, is to remove inconsistencies and weed out possible bugs/errors during development phase. How so?\nAs we saw above, functions with the keyword function and variables with var can be called before declaring them. This is because in both these cases, the functions/variables are initialised either with undefined (for variables), or as functions for function variables - and hence can be accessed later on. This can seem beneficial for haphazard coding, but in the real world (production), this can lead to huge unintended errors.\nTake this small example -\nAs we can see, cartItems is declared with var in line 5 - but it is already being accessed in line 1. Still, there are no errors, and as usual, it would be initiated with undefined - making it possible to be accessed before it is declared.\nWe have an if block that checks for the truthy or falsy state of cartItems and then, only if found to be falsy, we want the deleteCart() function to be invoked.\nNow the problem arises - in line 5, we declare cartItems as 10 but still, the deleteCart() function is invoked and the damage, so to speak, is done. The cart items are deleted.\nOnly in line 10, do we see that finally when the execution context has moved out of the declaration phase, and into the execution phase, the value of cart items is updated from undefined to 10.\nWhy does the above scenario happen? Hoisting.\nFunction declarations with the keyword function and variables with var are both hoisted and this can and will lead to bad errors in a huge application.\nBut what happens to variables with let and const? Welcome to Temporal Dead Zone.\nTemporal Dead Zone let and const variables are not initialised during Declaration Phase. They do not get an undefined or anything of the sort when they are created. Instead, from the beginning of the flow of execution right until the time of their declaration, let and const variables are said to be in a zone often called the Temporal Dead Zone.\nWell, it may sound ominous and eerie, but it does suit the state and situation of the variables perfectly. A small illustration -\nAs can be seen, the variable job declared with var has been initiated to undefined but the variables numOne and sum declared with let and const respectively, are both empty \u0026ldquo;boxes\u0026rdquo;. And when it comes to execution phase, we get the console statement for job but not for the other two variables. In fact, the execution stops as soon as it encounters the second console statement, since it cannot find the initialisation for numOne and hence, it terminates the execution flow with the error message - Error: Cannot access 'numOne' before initialisation -\nThis behavioural difference holds true for Function Declarations vs Function Expressions as well.\nSimply put - Function Declarations are hoisted, while Function Expressions and Arrow Functions are not. Like so -\nHere, add() is a function declared with var so it hoisted and no errors are found. But when it comes to subtract(), it a function expression that is assigned to the variable sub - and even though it is declared with var, it it still an expression, so it does not get hoisted/initialised. The execution stops here with an error message.\nSame is the case with multiply() - with a different error message like so -\nHere, we can clearly see that from the error message, the `multiply` variable declared with let, is a function expression and therefore has not been initialised at all.\nClosing Notes All of this is a solid showcase of why we need best practices, and why we must adhere to it in \u0026ldquo;strict\u0026rdquo; mode while writing real world code. To summarise -\nUse let and const everywhere. Using var is outdated, and unnecessary in almost all modern use cases.\nAlways, always declare variables and functions before using/invoking them.\nAgain, use const for all function expressions.\nYou cannot prevent Hoisting from happening, but can certainly control when and where you would need it.\nWe have almost made it through the muddy waters - these behind the scenes functionalities and concepts are building blocks for what\u0026rsquo;s ahead - but for now, maybe a small celebratory dance is in order?\nOr not ðŸ˜ƒ\nSee you in the next one! Until then,\nKeep shipping ðŸš€\n","permalink":"http://vinoo.in/blog/hoisting-temporal-dead-zone/","summary":"Before we define Hoisting, you should know that we have already seen Hoisting in action in our previous article and code snippets, and you would probably be writing code every day that implements Hoisting without consciously being aware of it! It is a very tricky concept, one that is simple enough in practice but takes some time to wrap our heads around, given the idiosyncrasies of JavaScript ðŸ˜ƒ\nLet\u0026rsquo;s do a quick recap by examining the code below -","title":"Hoisting and Temporal Dead Zone In JavaScript"},{"content":"What is Scoping? Scoping is a way to organise and access variables. In JavaScript, there is a concept called Lexical Scoping - which is a way of controlling Scope of variables by the placement of functions and blocks in the code.\nWhat is Scope? Scope is simply the space or environment in which it is declared.\nScope of a variable is a region of the code where the variable can be accessed.\nIn the case of functions, Scope is the variable environment which is stored in the function\u0026rsquo;s execution context.\nThere are 3 types of scope -\nGlobal Scope - for all top level code\nThe variables are declared outside of any function or block.\nThese variables that are declared in global scope are accessible everywhere in the code.\nFunction Scope - this type of scope is created each time a function is declared.\nVariables declared in this function are only accessible within this function, and not outside of it.\nThis is also called local scope\nfunction funcScope() { const a = 123 const b = 321 const diff = b - a return diff } console.log(b) // ReferenceError As can be seen above, trying to access the variable b gives a ReferenceError since we are trying to access it outside its scope.\nIt also does not matter what type of function we are using - function declarations, function expressions, arrow functions - all create their own scope.\nBlock Scope (ES6) - beginning from ES6, blocks can also create scopes. Blocks are created by curly braces in JavaScript, and any variable within these braces is said to be scoped to that particular block.\nBlocks are created by if statements, for loops, etc.\nNOTE: Block scope is only applicable to variables declared with let and const.\nvar variables declared within a block are still accessible outside of it too.\nFrom ES6 onwards, all functions are also block scoped - only in strict mode.\nif(login) { const greet = \u0026#39;Welcome\u0026#39; } console.log(greet) // ReferenceError Here, the if condition has created a block so scope of the variable greet is restricted to this block. Trying to access it outside of the block results in a ReferenceError.\nScope Chain Let us walk through the below code snippet and examine the scope chain implemented for global and function scopes -\nconst myName = \u0026#39;Vinoo\u0026#39; // Global variable // The below function \u0026#34;first()\u0026#34; is also technically a global variable // since all functions and function expressions are considered // variables; but for this code snippet we will consider only variable // declarations for global scope const myName = \u0026#39;Vinoo\u0026#39; function first() { const experience = 4 if (experience \u0026gt;= 4) { var seniorDev = true } function second() { const job = \u0026#39;Developer\u0026#39; console.log(`${myName} is a ${experience} years experienced ${job}`) } second() } first() As we can see, myName has global scope and functions first() and second() have function scopes set for the respective variables declared in them. However, notice that the variables myName and age are being referenced within the function second - but their scope is supposed to be limited to the function block of second() right?\nThis is where the scope chain comes into play - when one scope needs to use variables from another scope, it will \u0026ldquo;look up\u0026rdquo; in the scope chain and see if it can be used. This is called the \u0026ldquo;variable lookup\u0026rdquo; in the scope chain. In other words, a scope has access to variables declared in the outer scopes. In this case, the function second() looks outside of its scope to access the variable values from outer scopes - from first() and the global scope for myName.\nThis is also known as Lexical Scope - the ability of an inner function scope to access variables from the parent scope.\nNOTE: Scopes simply look up for the variable\u0026rsquo;s value in the scope chain and never actually copy the variables itself to use in their own scopes.\nAlso, the scope chain only works upward - meaning, only an inner scope can look up the scope chain for variables and not the other way around; an outer scope will never have access to the inner scope variables.\nWe are now clear with the scope chain implemented for function scopes. However, in the above snippet, line numbers 6 to 8 contain an if block. Remember, only starting from ES6 implementation, we have block scopes functionality with let and const variable declarations. But, we can see in the snippet, we have a variable declared within the if block with var.\nThis means that var has no block scope - but it is still limited to the function that it is declared within; it has function scope.\nlet and const are block scoped.\nvar is function scoped.\nTherefore, in our code snippet - the variable seniorDev is not scoped to the if condition within which it is declared; instead, it is scoped to the function first(). Incidentally, the function second() can access this since it is declared within the function first().\nIn essence, the below illustration captures the Scope Chain for the above code.\nThat was it for Scope and Scope Chain in JavaScript! We have given enough lunges for the brain with this topic.\nTo really get basics right, you should alter the above code snippet and experiment with it by declaring variables in different scopes and tinkering with the flow.\nIn the next post, we will dive into Hoisting and the this keyword - thereby working towards cementing our foundational knowledge of how JavaScript works.\nSee you in the next one ðŸ‘‹\nKeep shipping ðŸš€\n","permalink":"http://vinoo.in/blog/scope-in-javascript/","summary":"What is Scoping? Scoping is a way to organise and access variables. In JavaScript, there is a concept called Lexical Scoping - which is a way of controlling Scope of variables by the placement of functions and blocks in the code.\nWhat is Scope? Scope is simply the space or environment in which it is declared.\nScope of a variable is a region of the code where the variable can be accessed.","title":"Scope in Javascript"},{"content":"JavaScript Engine A JavaScript engine is simply put - a program that executes JavaScript code. Each browser has its own JS engine. Firefox has SpiderMonkey, Microsoft Edge has Chakra, Opera has Caraken, etc. These are all customised JavaScript and WebAssembly implementations depending on the browser\u0026rsquo;s architecture. The most widely used is of course, Google Chrome browser and its engine is called V8.\nV8 is built mainly with C++, and it powers Chrome as well as NodeJS which is a JS runtime to build server-side applications.\nWhat does the JS Engine consist of? The JS Engine has two main components - a Call Stack and a Heap.\nThe Call Stack is where our gets executed using something called the Execution Context. The Heap is an unstructured memory pool which stores all the objects that our application needs. We will discuss this in detail soon below, but let\u0026rsquo;s rewind for a bit here.\nRemember in our previous post we had read that JavaScript is an interpreted language? Well, it is not 100% true since interpreted languages are much slower than compiled languages and modern applications cannot afford to be that slow. This is why the modern JS Engine now has a mix of compilation and interpretation - called Just-In-Time compilation.\nCompilation - The entire source code is converted to machine code once, and a binary file is created which contains this converted machine code; finally this file will be executed later by a computer. Compilation is done \u0026ldquo;ahead of time\u0026rdquo;.\nInterpretation - The source code is \u0026ldquo;interpreted\u0026rdquo; and executed line by line by the interpreter. In other words, compilation and execution are done sequentially, line by line. The downside is that multiple executions of the same source code will be interpreted again and again.\nNow that this above difference is clear, JIT is a bit easier to understand. The ahead-of-time compilation still exists, but no file exists to be executed. The execution happens immediately after compilation - which is perfect for JavaScript to do compilation and execution simultaneously rather than line-by-line interpretation.\nHow does the code get executed? As discussed before, our code first enters the JS engine to begin the process of execution.\nOnce the code enters the engine, it is parsed - which means the code is being read. This code is parsed into a data structure called the \u0026ldquo;AST\u0026rdquo; - Abstract Syntax Tree.\nThis AST is then compiled into machine code - and finally is executed immediately in the Call Stack.\nNow this is the most important piece of the puzzle - what is the Call Stack and where did it come from? To understand this, let\u0026rsquo;s start off with a diagram -\nMDN defines call stack like this - A call stack is a mechanism for an interpreter (like the JavaScript interpreter in a web browser) to keep track of its place in a script that calls multiple functions â€” what function is currently being run and what functions are called from within that function, etc.\nEssentially, it is used to keep a record of all the execution contexts (more on this below) - global execution context, function execution context, etc - in an order which are then executed by the JS engine.\nConsider the following code -\nfunction calculate() { // random code // .. add() // some other code after add() function // .. } function add(a, b) { return a + b } calculate() Here, all the functions, both global and inner, are collected and put into the call stack in a certain order to be executed later on. If there are any Web APIs like fetch, timer, etc then they will be pushed into the call stack for execution only once the call stack is empty - meaning once all the functions within call stack are processed, only then will these API methods be pushed into the call stack. This is because these web APIs are not part of the native JS engine itself; rather, JS gets access to these APIs through the global window object. This process can be visualised like so -\nAll the callback functions that add and enhance interactivity to our web apps - onClick, setInterval, etc are first put into a data structure called the Callback Queue. And then, as mentioned before, once the Call Stack is empty, the callback functions are pushed to the Call Stack for execution.\nHow exactly do these callback functions get pushed to the Call Stack, and when does the Callback Queue know when to push?\nThat\u0026rsquo;s exactly where the Execution Context as a concept wins ðŸ˜Ž Let\u0026rsquo;s see how it works, below.\nExecution Context Simply put, Execution Context is an environment created by the JS Engine when code begins executing. This environment is for top level code - variable and function declarations only. Take a look at the diagram below -\nAs you can see, the Execution Context here is named \u0026ldquo;Global Execution Context\u0026rdquo; (GEC) - which is what gets created by the JS Engine when the program is run for the first time.\nGEC has two sections - one for storing data (variables, functions, etc), and another for execution of the program (returning values). Now that we know what an Execution Context is, let\u0026rsquo;s understand how code is actually executed by the GEC.\nFollowing the creation of a Global Execution Context at the beginning of the program execution, the thread of execution of the code happens in two phases -\nDeclaration Phase Execution Phase Consider the following code -\nlet numOne = 21 function square(num) { return num * num } let result = square(numOne) let username = \u0026#39;Arya\u0026#39; function greet() { return `Hello ${username}` } greet() Let us examine how this code gets executed phase by phase in the Execution Context. As soon as we run the program, the JS Engine creates a Global EC as we saw earlier.\nDeclaration Phase Once the GEC is created, we enter the Declaration Phase -\nNow, the first line of code - let numOne = 21 is a variable declaration. Note that declaration and assignment are two different things. let numOne is a variable declaration, while numeOne = 21 is a variable assignment. So, in the GEC, within the Memory, a variable with the name numOne is created with its value being currently undefined - since we are still in the declaration phase. The next line, function square(num) ... is also a function declaration which has an argument num - so, for all purposes, this function is a declaration of variable again. Again, in the memory, a function variable with the name square gets created with. Whatever is within the function block is ignored for now. Next, we have let result = square(numOne) which is a variable declaration since we are assigning the function call of square(numOne) to a variable called result. So, result gets stored in the Memory - again with the value undefined for now. Next up, we have the variable let username = 'Arya' - same as the above step. Lastly, we have the function declaration greet() - which gets created in the Memory. This entire process of Declaration Phase can be visualised through the illustration below -\nExecution Phaase Once the Declaration Phase is done, we enter into the Execution Phase. The execution context looks for all function executions like function calls, return statements, etc here. This is the thread of execution that follows for the above code -\nnumOne is assigned a value of 21, so in the Memory, the value of numOne changes from undefined to 21 function square(num is just a declaration so this block is skipped. Next up, we have the result variable being assigned a function call square(numOne) - this is where an important part of the Execution Context comes into picture. Every time the thread of execution encounters a function call, the Global Execution Context creates a separate environment - Function Execution Context (FEC). This means that an FEC is created for each function call in the code execution. And once the function execution is done - which is indicated by return statements - that particular FEC is deleted from the GEC.\nSo now, continuing the above thread of execution for the variable result -\nA separate FEC is created, with its own Memory and Execution sections. Again, this FEC block follows its own Declaration Phase and Execution Phase. result is assigned a function execution of square(numOne). Now, square was declared earlier with the argument num - this argument num is also considered a variable declaration for the function square. A declaration phase begins in the FEC created within the GEC for this particular function. num is stored in Memory with initial value undefined. No other declarations are available in square(numOne), so we enter into Execution Phase. Now in Execution Phase, we have the value for num as 21 from the GEC\u0026rsquo;s Memory; so the value for num changes from undefined to 21 here. The function square returns num * num so this is executed in the Execute section of the FEC. Since we have the value for num now, the value of 21 * 21 = 441 is calculated and returned. This returned value of 441 is now assigned to the variable result for which this separate FEC was started in the first place. Once this function is done executing, the FEC instance for square is deleted. Moving on from result now - we have the variable username which gets the value Arya assigned to it. Next, the function greet is already declared, so we skip this step. Finally, the greet function is called, which means another FEC is created within the GEC for this function. Within the FEC, we first go into declaration phase - but since there is no declarations in the function greet, we move on to the execution phase. The return statement here calls in the value of the variable username - which just got a value assigned to it above. So the statement Hello Arya is returned, which means the execution phase is done, which means the FEC for greet function is done, which means that the statement Hello Arya is returned to the GEC\u0026rsquo;s Memory, and this particular FEC instance is now deleted. THAT. WAS. EXHAUSTIVE.\nBut in a good way though ðŸ¤“\nThese concepts can take some time, and repetition, to grasp a solid understanding of, but these are important to lay a solid foundation of how we write native JavaScript in various scenarios, and also helpful in debugging.\nIn the next post, let\u0026rsquo;s study about Scope and the Scope Chain - and why it is important to understand how it works.\nKeep shipping ðŸš€\n","permalink":"http://vinoo.in/blog/javascript-engine-execution-context/","summary":"JavaScript Engine A JavaScript engine is simply put - a program that executes JavaScript code. Each browser has its own JS engine. Firefox has SpiderMonkey, Microsoft Edge has Chakra, Opera has Caraken, etc. These are all customised JavaScript and WebAssembly implementations depending on the browser\u0026rsquo;s architecture. The most widely used is of course, Google Chrome browser and its engine is called V8.\nV8 is built mainly with C++, and it powers Chrome as well as NodeJS which is a JS runtime to build server-side applications.","title":"Javascript Engine and Execution Context"},{"content":"Let\u0026rsquo;s take a breather from the code editor today - in the next immediate post, we would be reading concepts along with code examples, but for this now, let\u0026rsquo;s make some time to simply read through some interesting things about JavaScript as a language. Let\u0026rsquo;s go ðŸ‘‡\nWhat Actually IS JavaScript? High Up There JavaScript is one of the \u0026ldquo;high level\u0026rdquo; languages in the programming ecosystem. The reason is that it abstracts away a lot of system level configuration that we would need to do in C language - creating and storing variables, hardware resource allocation, memory management etc.\nLanguages like Python and JS are designed in such a way that we do not need to manage any of these. While this is the upside, the downside is that we compromise on performance, efficiency, and speed.\nOne of these abstractions is \u0026ldquo;Garbage Collection\u0026rdquo; that is present in the JS engine. It automatically removes old, unused objects from the memory.\nInterpreting It Right Computers only understand binary and in order for us to write machine code that is both understandable to the computer and readable by humans, programming languages are designed to accommodate this. And JavaScript, is no different. Its abstraction layers in the JS engine convert our readable code into machine code.\nThis makes JS an \u0026ldquo;interpreted\u0026rdquo; language.\nOOP(s?) How do arrays get all their methods (push, shift, splice, etc) ready to use as soon as we define them? We never defined the \u0026ldquo;properties\u0026rdquo; of an array, let alone instruct what functions/methods that can be called upon it.\nWell - to highly abstract it to the point of intellectual danger, here is an explanation - this is possible due to ALMOST everything being an object in JS (stress on the word \u0026ldquo;almost\u0026rdquo;!).\nExcept for primitive values like numbers and strings, entities like arrays are treated as objects too. Arrays are created from the \u0026ldquo;prototype\u0026rdquo; in JS - a blueprint/template that contains all the methods defined in it. The arrays that we create then \u0026ldquo;inherit\u0026rdquo; these methods.\nWe will cover a lot more in detail about objects and their workings in a later post where this abstraction - and confusion - will be replaced with the actual insight into how objects and methods work.\nFunctional First In addition, functions in JS are known as \u0026ldquo;first-class functions\u0026rdquo; - a term used when functions are treated as variables. This is what gives a programming language like JS the ability to pass functions into other functions (callbacks, references, etc), return functions from functions, etc. More commonly, this is known as functional programming.\nType Free? One other important feature (or a bug?) is that JavaScript is a dynamically typed language. Now, not to spark debates - but there are pros and cons to it, and with JS having a strong hold over all kinds of applications (seriously - JS is almost everywhere in every major app now ðŸ¥²), the need for \u0026ldquo;strongly\u0026rdquo; typed languages is very much the case.\nWe do not explicitly assign data types to variables. We just declare variables with the necessary scope, but the type is assigned when the JS engine executes our code.\nQuirky fact - a let x = 23 can look like it\u0026rsquo;s a number, but when we use typeof to console x while playing around with the DOM - surprise, it\u0026rsquo;s a string.\nWe can reassign the type of variables when we reassign values to those variables. This is what a dynamically typed language looks and works like.\nThis is a major reason why scalability takes a hit when apps use pure JS. And also why TypeScript is fast gaining popularity and in fact, becoming a de facto choice for apps across the developer ecosystem.\nStill - not to worry - we will still be studying everything about JS, building secure, fully functioning apps with JavaScript like everyone has been for the last 2 decades ðŸ“ˆ, and JS will still continue to be awesome for many years to come.\nVery soon, I will be creating a complete TypeScript series as well, so watch out for it ðŸ¤“\nThread-ing Lightly In Operating System terminology, a thread is like a set of instructions that is executed in the CPU. The thread is where our code is executed in a machine\u0026rsquo;s processor.\nNow, JavaScript is a single threaded language. This means at any given time, only one single task (or one set of tasks) can be executed. This is obviously a huge pitfall - what if there is a thread that fetches data from an API and the response takes a very long time? This would block the processor from running any other tasks.\nThis is where the concurrency model comes into play. A concurrency model defines how multiple tasks should be handled by a programming language. In the case of JS, we need a non-blocking behaviour which can be achieved by using an \u0026ldquo;event loop\u0026rdquo;.\nThe event loop takes complex/long running tasks, executes them in the background, and then puts them back in the main thread once they are done.\nAgain, this is simply an oversimplification and we will definitely dive deeper in the next post.\nWell, that was fun (I hope!). Studying a programming language\u0026rsquo;s core fundamentals is very essential since it helps us \u0026ldquo;think\u0026rdquo; in that language in the long run. The next post will be up soon and it will cover concepts like the JS Engine, Runtime, Execution Context, the Call Stack, Scoping, Hoisting, and much more.\nKeep shipping ðŸš€\n","permalink":"http://vinoo.in/blog/javascript-under-the-hood/","summary":"Let\u0026rsquo;s take a breather from the code editor today - in the next immediate post, we would be reading concepts along with code examples, but for this now, let\u0026rsquo;s make some time to simply read through some interesting things about JavaScript as a language. Let\u0026rsquo;s go ðŸ‘‡\nWhat Actually IS JavaScript? High Up There JavaScript is one of the \u0026ldquo;high level\u0026rdquo; languages in the programming ecosystem. The reason is that it abstracts away a lot of system level configuration that we would need to do in C language - creating and storing variables, hardware resource allocation, memory management etc.","title":"Javascript Under the Hood"},{"content":"Intro DOM - stands for Document Object Model. Think of it as a tree that with multiple branches that fan out to indicate and serve different elements on the web page. Now, each branch can be referred to by its own \u0026ldquo;name\u0026rdquo;.\nHow do we give the name? This is done through the HTML document of the web page we just talked about. So essentially, the DOM is a structured representation of these documents, and by using JavaScript and its various built-in methods, we can access these documents to manipulate them.\nNow, that\u0026rsquo;s a strong word. What exactly do we \u0026ldquo;manipulate\u0026rdquo; here? Simply put, we can access, modify, and control the behaviour, look, and feel of all the elements on a web page represented by the DOM tree. This includes changing text, HTML attributes, CSS styles, and more. Yay!\nWhere is DOM located? But where does the DOM come from? The DOM is automatically created by the browser as soon as our web loads, and is then stored in a tree structure somewhat visually imagined as below -\nThe \u0026ldquo;document\u0026rdquo; - essentially the entire web page once it is loaded by the browser - is an object that we can access, in JavaScript. Think of it as the entry point into the DOM. There are various methods (functions) available in the document object, querySelector being the most common one. Hierarchically, the html element is the first \u0026ldquo;child\u0026rdquo; element of the document object. It serves as the root element for all other elements on the page.\nFrom there, it\u0026rsquo;s a complete tree of elements with all the sibling and child elements nested according to their semantic value.\nðŸ’¡ Note that the document object and its inherent functions are NOT equivalent to the language JavaScript itself. JavaScript is a \"dialect\" of the larger ECMAScript ecosystem. The DOM and its functions \u0026amp; properties actually come from Web APIs which are libraries available through the browser, and which can be accessed by JavaScript. There is an official DOM specification that browsers implement which is why DOM manipulation works the same across all browsers.\nHow to perform DOM operations? Now that we a basic understanding what the DOM is, let us see how we can work with the DOM and apply various methods to make our web page interactive.\nAs mentioned before, the DOM comes with a collections of functions and properties which we can invoke in any ECMAScript dialect. Which means, JavaScript as a language, is able to call these functions just like any other method.\nDOM Properties and Methods A few of the most common document methods are -\nquerySelector - enables us to query the DOM and select a particular element with its class name. It can either be a single element with a unique class name or multiple elements with the same class name. In case there are multiple elements with the same class name, then they are all queried with querySelectorAll and stored in something called a Nodelist - which is an array of all the items/elements we have queried. Suppose we have a div HTML element with the class name main-content, we query it like below - // Query the element and assign it to variable const mainContent = document.querySelector(\u0026#39;.main-content\u0026#39;) /** NOTE - we can see that there is a \u0026#34;.\u0026#34; (dot) before the class name in the query method. This is mandatory to be applied to query all class names */ getElementById - this is similar to querySelector but as the method name suggests, it is used to the query the element by its unique id name. id names are unique since no two elements can have the same id. If our div element above had an id of #main-content, then we query it by - const mainContentID = document.getElementById(\u0026#39;main-content\u0026#39;) /** NOTE - there is no need to have a \u0026#34;.\u0026#34; or a \u0026#34;#\u0026#34; to specify the id name since getElementById does the work for us */ addEventListener - all interactivity that we would need for our web application, is going to be defined in and handled by this method. Think of this as the one major method that we can use to keep track of various interactions - touch, single click, double click, triple click (we can even customise the number of clicks! ðŸ˜) mouse hover/movements, etc. There are a huge number of properties that this method has to offer and we will possible dive deeper into it in the future articles. Example - const btnElement = document.querySelector(\u0026#39;.main-btn\u0026#39;) btn.addEventListener(\u0026#39;click\u0026#39;, function() { // define interaction/function here } As can be seen here, we attach the addEventListener method to the element with which we want to interact and then define the action we want performed once the \u0026ldquo;event\u0026rdquo; (click, touch, etc) happens. We can even add, remove, and toggle classes dynamically after an event/action happens. Few of the methods are -\nclassList.add() and classList.remove() - as the name suggests, classList is a property that returns the CSS classes for the element. We can then use methods like add() and remove() to manipulate the same. A very abstract random example - const mainDiv = document.querySelector(\u0026#39;.main-div\u0026#39;) if (isLoggedIn) { mainDiv.classList.add(\u0026#39;login-bg\u0026#39;) } else { mainDiv.classList.remove(\u0026#39;header-bg\u0026#39;) } classList.toggle() - this is an interesting one, and very useful too. This helps us check if the class we want for an element is already added, and if not, adds it - and vice-versa. Removes a class if it already exists. A simple example to switch players when a certain condition is met - const playerOne = document.querySelector(\u0026#39;.player-one\u0026#39;) const playerTwo = document.querySelector(\u0026#39;.player-two\u0026#39;) document.getElementById(`current--${activePlayer}`).textContent = 0 activePlayer = activePlayer === 0 ? 1 : 0 player0El.classList.toggle(\u0026#39;player--active\u0026#39;) player1El.classList.toggle(\u0026#39;player--active\u0026#39;) createElement() - we don\u0026rsquo;t always have to have an HTML structure defined beforehand modifying it via DOM. The createElement() method helps us create new elements and then add them to the DOM by using other methods (discussed in the next point). Example - const paragraphSection = document .createElement(\u0026#39;section\u0026#39;) .classList.add(\u0026#39;my-section\u0026#39;) const paragraphWrapper = document.createElement(\u0026#39;div\u0026#39;).classList.add(\u0026#39;my-div\u0026#39;) const paragraph = document.createElement(\u0026#39;p\u0026#39;).classList.add(\u0026#39;my-paragraph\u0026#39;) appendChild() - once we have created an element from the above method, we then add or \u0026ldquo;append\u0026rdquo; it to the DOM using the appendChild() method. This adds the new element as the last child of the parent element. If the element we are adding already exists, somewhere higher up in the tree, then using this method will remove it from its existing position and add it to the bottom. Continuing the previous example - mainEle.appendChild(paragraphSection) paragraphSection.appendChild(paragraphWrapper) paragraphWrapper.appendChild(paragraph) This would create the below structure in the DOM - (notice in the earlier example that we added class names to each element using the classList property) \u0026lt;main\u0026gt; \u0026lt;section class=\u0026#39;my-section\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;my-div\u0026#39;\u0026gt; \u0026lt;p class=\u0026#39;my-paragraph\u0026#39;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/main\u0026gt; removeChild() - as the name makes it clear, it simple removes the specified element from the DOM. More specifically, the parent HTML element calls this method with the child element\u0026rsquo;s name specified, which then removes the child element from the tree. There are a lot more properties and methods that the document object has to offer - a thorough explanation and references can be found at MDN documentation. This post has covered the basics of DOM and how to get started with making simple modifications in DOM tree to add any kind of interactivity we need for our application.\nThis is the first post in The Complete JavaScript Series. Stay tuned for more!\nIn the upcoming posts, we will dive deeper into the workings of JavaScript and explore a few rarely encountered concepts.\nKeep shipping ðŸš€\n","permalink":"http://vinoo.in/blog/what-is-dom-in-javascript/","summary":"Intro DOM - stands for Document Object Model. Think of it as a tree that with multiple branches that fan out to indicate and serve different elements on the web page. Now, each branch can be referred to by its own \u0026ldquo;name\u0026rdquo;.\nHow do we give the name? This is done through the HTML document of the web page we just talked about. So essentially, the DOM is a structured representation of these documents, and by using JavaScript and its various built-in methods, we can access these documents to manipulate them.","title":"What is DOM in JavaScript?"},{"content":"There are probably hundreds, even thousands of articles on this topic. And that\u0026rsquo;s precisely the reason why it can also get daunting, confusing, and borderline nauseating to understand how to setup, much less use SSH as a beginner.\nThis post is aimed to be a no-nonsense, no-fluff guide to creating multiple SSH keys for difference Git based accounts like GitHub or BitBucket, and manage all of them easily, simultaneously.\nDisclaimer: This is not an expert guide, and the steps here are simplified to ensure all levels of developers can follow. In case of any discrepancy or incorrect steps, please let me know in the comments and I would be happy to correct.\nIt is recommended to complete the below steps from beginning to end for one key and then repeat the process for all keys thereafter.\nStep 1 - Check for existing keys Use the command below to check if there are existing SSH keys -\nls -al ~/.ssh\nIf you need a clean slate and start setting up everything afresh, delete the existing entries with this command -\nssh-add -D\nNote that this will only delete the manual entries previously done by you and not the ones automatically added by other agents/tools. To ensure that the .ssh folder is empty, simply delete the contents of the folder like you normally would.\nFiles beginning with a dot \u0026lsquo;.\u0026rsquo; are irrelevant in this context. SSH key names look like this -\nStep 2 - Generate new SSH key Type in this command to generate a new SSH key -\nssh-keygen -t ed25519 -C \u0026quot;your@email.com\u0026quot;\nMeaning of different flags in the above command -\n-t : defines the type of algorithm that generates the key; RSA, ed25519, etc. ed25519 is a more encrypted, more secure algorithm -C : used to define any comment to identify the particular entity who generates the key. Optional, but always recommended Once entered, the above command generates the SSH key. Make sure you enter a unique name within the path, else the file name will default to id_rsa. Your screen should resemble like so -\nHit Enter through the next steps (paraphrase, et al), and your keys will be generated; Two files - a private key and public key will be generated.\nStep 3 - Create a known_hosts file Nothing fancy; simply go inside the .ssh folder with cd .ssh and create a file named known_hosts_yourkeyname. This helps you easily diagnose issues should they occur in future. Use the command below to create it -\ntouch known_hosts_yourkeyname\nLeave it untouched after this.\nStep 4 - Create/Edit the config file The config file is used to define and set options for each key and its corresponding host. Open the .ssh folder in your preferred editor and create a new file named config (without any extensions) and paste the following lines into it -\nHere is a brief breakdown of what each line means -\nHost : This is used to identify each key amidst the different ones in your system. Keep it simple with the URL of the host as above. HostName: This is where your remote repository exists. This is what is used to match with your repo\u0026rsquo;s base URL. For a default SSH key which is usually a personal one, keep the HostName entry the same as the Host. For work SSH keys, you can modify the HostName like so -\nUser : For git based hosts/servers, the entry will be git. If it is a Digital Ocean Droplet or AWS instance, it may vary accordingly. AddKeysToAgent : In a further step, we will add the SSH keys to the ssh-agent in the system - which is a program that keeps track of identities and passwords, so that you do not have to enter your credentials each time you perform git read/write operations. In this line, we are prompting the private key to be authenticated by the ssh-agent. IdentityFile : This is the path of the SSH key UserKnownHostsFile : This is used to store all connections to hosts that your key connects to. Specify the name of the known_hosts file you created earlier using the touch command. IdentitiesOnly : This entry is used to ensure that only the specified keys are used to connect to a host, and no other. NOTE: Once you generate more keys, you will need to simply add the same set of lines as above for those new keys. We will see an example of this at the end of the article.\nStep 5 - Add the keys to ssh-agent Enter the command below -\neval \u0026quot;$(ssh-agent -s)\u0026quot;\nA unique Agent PID will be displayed which means that the ssh-agent is now running.\nNext, add the keys to it -\nssh-add --apple-use-keychain ~/.ssh/your_keyname\nIf you are not on a Mac, do not use the --aple-use-keychain flag. This is for the newer keychain access management in MacOS versions after Monterey. If you are using an older version or are on Linux, replace it with this -\nssh-add -K ~/.ssh/your_keyname\nYou will get a line confirming the key was added.\nStep 6 - Add the key to your host Make sure you\u0026rsquo;re inside the .ssh folder. Then, copy the contents of your public key like so -\ncat your_keyname.pub | pbcopy\ncat is to display the contents of the public key, and simultaneously, with the pipeline operator, we use pbcopy to copy the contents to the system\u0026rsquo;s clipboard.\nNext, add this to your host. If you are on GitHub, go to your account Settings\u0026gt;SSH and GPG Keys and add the key.\nStep 7 - Verify and start SSHing The last step is to verify that your configuration is up and running. Enter this command -\nssh -T git@github.com\nSuppose you have repeated the process up until Step 6 for two other keys and you now have two keys, with the second key supposedly on GitHub again, and the third key on BitBucket, then your config file should look similar to this -\nAs you can see, there are multiple hosts with multiple corresponding keys and all of them are pattern matched by the ssh-agent to connect only as specified. Notice how the Host entry for GitHub work account and BitBucket account are unique.\nYou can now verify the configuration for all of them -\nssh -T git@github.com\nssh -T git@github-work\nssh -T git@bitbucket.org\nYou should get a success message for each of them indicating that authentication was successful -\nHi some_user! You've successfully authenticated, but GitHub does not provide shell access.\nVoila! ðŸŽ‰ You are now all set to clone your repos from the hosts you have setup.\nAn important thing to notice here is that in our example above, we have 2 GitHub hosts where the HostName entry points to github.com but the Host entry is kept different in order for the ssh-agent to uniquely identify each of them.\nTherefore, when you are cloning a repo from the Default Personal account, you can simply type in -\ngit clone git@github.com:your_username/your_repo_name.git\nHowever, when you want to clone a repo from the Work GitHub account, you would have to change the base URL of the repo after the part git@, with your corresponding Host entry, like so -\ngit clone git@github-work:your_username/your_repo_name.git\nIf it is a different host altogether like the Bitbucket one, then you can simply use the clone command like usual.\nThis brings us to the end of this rather long, but detailed article on how to setup multiple SSH keys for multiple hosts in your system.\nHave fun setting up, and do let me know in the comments, if you have any suggestions. Until next time ðŸ––\n","permalink":"http://vinoo.in/blog/how-to-setup-ssh/","summary":"There are probably hundreds, even thousands of articles on this topic. And that\u0026rsquo;s precisely the reason why it can also get daunting, confusing, and borderline nauseating to understand how to setup, much less use SSH as a beginner.\nThis post is aimed to be a no-nonsense, no-fluff guide to creating multiple SSH keys for difference Git based accounts like GitHub or BitBucket, and manage all of them easily, simultaneously.\nDisclaimer: This is not an expert guide, and the steps here are simplified to ensure all levels of developers can follow.","title":"How To Setup SSH Keys For Multiple Hosts"},{"content":" This post was originally published here.\nIn a previous post, we saw how to use this keyword with objects. In this post, we shall dive deeper into different bindings of this that we will encounter when dealing with it in functions. Bindings mean the different ways this behaves in different contexts in a function.\n1. Default Binding Consider the following example -\nfunction defaultThis() { console.log(this); alert(`Welcome ${this.username}`); } defaultThis(); Since there is no username variable declared or defined, this keyword gets the default binding - it references the global Window object here, as can be seen below -\n2. Implicit Binding This binding is created by the behaviour of the function. Let\u0026rsquo;s take an example to understand -\nlet hobbit = { name: \u0026#39;Bilbo\u0026#39;, welcome() { alert(`Hello ` + this.name); } } hobbit.welcome(); The output would be as exptected -\nHere, since there is an object that calls the function welcome(), this implicitly refers to the object inside the function.\n3. Explicit Binding Explicit binding means to explicitly bind the value of this to any specific object.\nThere are 3 methods to implement explicit binding -\ncall() Consider the code snippet we used above in Implicit Binding - the property name and method welcome are both defined inside the object hobbit. This makes the binding for this fairly..implicit ðŸŒ. What if the object is separate from a method? Consider the snippet below -\nfunction welcome() { alert(`Welcome ${this.name}`); } let hobbit = { name: \u0026#39;Frodo\u0026#39; } welcome(); // Welcome welcome.call(hobbit); // Welcome Frodo The first function call welcome() has no reference to an object, so it would not return anything in the alert statement after Welcome.\nThe second function call is where we have accessed the object with the call method. This means that we are specifying to the browser to assign the object hobbit being passed as parameter to this using call method.\nAnother use case for call is that we can pass parameters to signify the value for this along with arguments for the function. Example -\nfunction foo(spellOne, spellTwo) { alert(`${this.name} cast the spells ${spellOne} and ${spellTwo}`); } let wizard = { name: \u0026#39;Ron Weasley\u0026#39; }; foo.call(wizard, \u0026#39;Expelliarmus\u0026#39;, \u0026#39;Slugulus Eructo\u0026#39;); Here, the function foo is called with the call method and the object wizard is passed as the first argument which automatically gets assigned to this in the function, along with the rest of the arguments. Note that the first argument always gets assigned to this.\nThe output is as below -\nBut there is a drawback for this use case. What if there are tens of arguments to be passed for multiple objects? Very cumbersome ðŸ˜• We have the next binding method to improve usability a little better.\napply() Take a look at this snippet -\nfunction foo(spellOne, spellTwo) { alert(`${this.name} cast the spells ${spellOne} and ${spellTwo}`); } let wizard = { name: \u0026#39;Ron Weasley\u0026#39; }; foo.apply(wizard, [\u0026#39;Expelliarmus\u0026#39;, \u0026#39;Slugulus Eructo\u0026#39;]); The format is the same, except that instead of call, we use the method apply, and instead of passing the arguments one after the other, we just wrap them in an array. The output remains the same.\nbind() The bind() method creates a new function which when invoked, assigns the provided values to this.\nTake a look at the snippet below -\nfunction foo(spellOne, spellTwo) { alert(`${this.name} cast the spells ${spellOne} and ${spellTwo}`); } let wizard = { name: \u0026#39;Ron Weasley\u0026#39; }; let castSpell = foo.bind(wizard, \u0026#39;Expelliarmus\u0026#39;, \u0026#39;Slugulus Eructo\u0026#39;); castSpell(); Here, we are using bind() to be referenced by the variable castSpell, which can then be invoked as a normal function call.\nThe advantages of using bind() are that -\nWe are explicitly binding the foo() method to the instance castSpell such that this of foo() is now bound to castSpell Even though the wizard object does not have castSpell as its property, because we are using bind(), wizard now recognises castSpell as its method bind() returns a new function reference that we can call anytime we want in future.\n4. new Binding new binding is used specifically for constructor functions. Take a look below -\nfunction Wizard(name, spell) { this.name = name; this.spell = spell; this.intro = function() { if(this.name === \u0026#39;Hermione\u0026#39;) { alert(`The witch ${this.name} cast the spell ${this.spell}`); } else { alert(`The wizard ${this.name} cast the spell ${this.spell}`); } } } let hermione = new Wizard(\u0026#39;Hermione\u0026#39;, \u0026#39;Occulus Reparo\u0026#39;); let ronald = new Wizard(\u0026#39;Ronald\u0026#39;, \u0026#39;Slugulus Erecto\u0026#39;); Constructor functions are special functions that are used to create new objects. The use of new keyword means that we are creating a new object (or instance) of the (constructor) function.\nWhenever new is used before any constructor function (name with the Capitalized convention followed), the JS engine undertands that this inside the function will always point to the empty object created by new.\n5. HTML Element Event Binding this can be used to bind the values of specific events or elements in HTML.\nTake a look at this example -\n\u0026lt;button class =\u0026#34;this-one\u0026#34; onclick=\u0026#34;console.log(this)\u0026#34;\u0026gt; this One \u0026lt;/button\u0026gt; In this case, this will always bind itself to the element where the event happened; in this case, the this-one class button.\nThe output will be as below -\nNow take a look at this snippet -\n\u0026lt;button class =\u0026#34;this-two\u0026#34; onclick=\u0026#34;this.style.backgroundColor=\u0026#39;orange\u0026#39;\u0026#34;\u0026gt; this Two \u0026lt;/button\u0026gt; Here, this is again bound to the button with the class this-two, and the onclick event happens only on that specific button.\nOutput -\nHow about when we call a function within the element?\n\u0026lt;button class =\u0026#34;this-three\u0026#34; onclick=\u0026#34;changeColor()\u0026#34;\u0026gt; this Three \u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; function changeColor() { console.log(this); } \u0026lt;/script\u0026gt; Note that we are calling the console.log() function along with this.\nSo, the value of this is as below -\nHere, this points to the global Window object. We can see that Default Binding occurs here since the function changeColor() is called without a prefix.\nthis is definitely strange. However, the use cases provide us with flexibility to use objects effectively.\n","permalink":"http://vinoo.in/blog/deeper-into-this-in-javascript/","summary":"This post was originally published here.\nIn a previous post, we saw how to use this keyword with objects. In this post, we shall dive deeper into different bindings of this that we will encounter when dealing with it in functions. Bindings mean the different ways this behaves in different contexts in a function.\n1. Default Binding Consider the following example -\nfunction defaultThis() { console.log(this); alert(`Welcome ${this.username}`); } defaultThis(); Since there is no username variable declared or defined, this keyword gets the default binding - it references the global Window object here, as can be seen below -","title":"Deeper Into This in Javascript"},{"content":"In the previous post , we saw how objects behave and what Dunder Proto means. In this post, let us discuss why Dunder Proto is used and how it can help us write better, optimised code.\nDunder Proto is mainly used for two cases -\nTo manage user methods for the objects that are created at runtime To increase usability through better memory management So how exactly does this efficiency happen? We know that __proto__ is a special property present in every object that we create in JavaScript. This property presents (and holds) different methods/key-value pairs for each object being created.\nAnd since every function is also an object, each function holds a set of methods as well that can be invoked right off the bat (like map(), filter(), etc).\nHere lies the advantage - you can (and should!) put all your methods in one place, in the Dunder Proto.\nWhy?\nBecause since it is already an existing property present in every object, there is no need to explicitly create a variable to manage those methods. Think about it - with each object you create, a whole list of methods get attached to it, leading to a bigger mess in terms of memory management. But by putting it all in the special bag that is the Dunder Proto, it is implicitly managed.\nExample -\nlet userMethods = { sayHello: function() { alert(`Welcome ${obj.name}!`); }, changeName: function(newName) { this.name = newName; return this.name; } }; function createUser(name, age) { let obj = Object.create(userMethods); obj.name = name; obj.age = age; return obj; } As can be seen, the methods sayHello() and changeName() are both put in a single object variable, which is then assigned to a variable using Object.create() method that accepts this object of methods as a parameter. These are now stored in __proto__ as shown below -\nNeat, right? ðŸ¥³\nThere is another property that exists to make your job even more easy, and the code more organised. Say hello to F.prototype.\nFunction.Prototype In the previous ways of creating and using object and methods, we used separate variables to store methods and object data. As our application becomes more complex, there are chances of code going out of hand. Using function prototypes can help us organise our code better.\nWhat is function prototype? Just like every object has a special property called Dunder Proto, every function in JavaScript also has a property called the Function Protoype. The use case for this property is that since it is a property of a function, it has its own Dunder Proto as well. Take a look below for clarity -\nHere, the function foo() has the prototype() property which in turn contains the __proto__ property.\nThis means that there is an even better bag to hold all our object data and methods in one place without the need for a separate function to create objects and a separate variable/object to hold methods. Using the function_name.protoype property, we can push all the data and methods to be stored in one single bag, for any number of objects that are created in future.\nExample -\nfunction Hobbit(name, age) { this.name = name; this.age = age; } Hobbit.prototype = { // Using the function.prototype property to put object\u0026#39;s methods displayName: function() { alert(`Hobbit\u0026#39;s name is ${this.name}`); } } Below, we can see that the methods as well as data are collected inside this F.prototype property.\nThe question here is - we used the F.prototype property to store the methods and data; but how did we instantiate the data to be stored along with the methods?\nThis is where the new keyword in JavaScript comes into picture.\nnew keyword is used to create an \u0026ldquo;instance\u0026rdquo; of an object. An instance here means that -\nA new object is created The methods are added to the prototype property of the function The this keyword automatically binds the newly created property to the object (and its prototype) The newly created object is then returned as well Like below -\nlet hobbitOne = new Hobbit(\u0026#39;Samwell\u0026#39;, 120); That\u0026rsquo;s it - a simple new keyword to make code (and life) easier ðŸ˜\nNotice that the code above looks almost the same as the previous method of object creation, except that the object is now returned implicitly with the usage of new keyword, as well as the data and methods are managed under a single property with the use of Function.prototype.\nConfused much? ðŸ˜ I would expect so; JavaScript is by no means easy. However, the way it offers such flexibility in writing code is what makes it interesting.\nIn the next article, I go into class, constructor and how our code can be even more organised than ever, binding all this knowledge neatly. Stay tuned to clear all your confusion ðŸ™‚\nUntil next time ðŸ¤  Keep shipping ðŸš€\n","permalink":"http://vinoo.in/blog/function-prototype-in-javascript/","summary":"In the previous post , we saw how objects behave and what Dunder Proto means. In this post, let us discuss why Dunder Proto is used and how it can help us write better, optimised code.\nDunder Proto is mainly used for two cases -\nTo manage user methods for the objects that are created at runtime To increase usability through better memory management So how exactly does this efficiency happen?","title":"Function Prototype in Javascript"},{"content":"In this post, we shall dive a bit deeper into nature of objects, and cover the Dunder Proto concept.\nNature of Objects Consider the below object -\nlet details = { name: \u0026#39;Richard Hendricks\u0026#39;, company: \u0026#39;Pied Piper\u0026#39;, }; In the above object, if we try to access the property company, it is possible since company is an existing property of the details object.\nHowever, the below snippet would return undefined -\nconsole.log(details.designation); //undefined This is because there is no property named designation inside details. This is exactly how we would expect an object to behave.\nHowever, take a look at the example below -\nlet arr = [1, 2, 4, 5, 7]; console.log(arr.map( () =\u0026gt; 21 ); The output would be as below -\nBut map() is not a method inside arr. So how is this being computed and where is this coming from?\nDunder Proto __proto__ Inside every object in JavaScript lies a special property called Dunder Proto. The name is coined due to the way this object is represented - __proto__ (accompanied by double underscore on both sides of the word proto).\nAs we can see in the above image, the object arr (and basically every object you create in JS), has the [[Prototype]]:Array property, inside which lies __proto__. If we expand this [[Prototype]]: Array property in our example, we should be able to see __proto__, which in turn contains a huge list of methods like every, forEach, map, splice, etc.\nThe point to be noted here is that each object we create has a different set of key-value pairs in the __proto__ property.\nWhenever we try to call/access a property that does not exist in the defined object, the JS engine goes down the __proto__ chain (or a rabbit ðŸ‡ hole), to search for that property. In the above case, we tried to compute the map() method on an array (which is an object), and it went down the __proto__ chain to look for the same.\nThis is how the hidden nature of object allows for all array, object, and string methods to be carried out.\nSince __proto__ is a special property of an object, it can be accessed as well. Suppose you want to add a new property under __proto__ to the details object above, this is how to do it -\ndetails.__proto__.alertMsg = function () { alert(`Hello Dunder Proto =\u0026gt; __proto__`); } This function is now added to the __proto__ property as can be seen below -\nWe learnt a hidden nature of objects in JavaScript, and the basics of Dunder Proto. In the next post, we shall learn about why and where Dunder Proto can be used to make our code more efficient.\nUntil next time! ðŸ™Œ\n","permalink":"http://vinoo.in/blog/dunder-proto/","summary":"In this post, we shall dive a bit deeper into nature of objects, and cover the Dunder Proto concept.\nNature of Objects Consider the below object -\nlet details = { name: \u0026#39;Richard Hendricks\u0026#39;, company: \u0026#39;Pied Piper\u0026#39;, }; In the above object, if we try to access the property company, it is possible since company is an existing property of the details object.\nHowever, the below snippet would return undefined -","title":"Dunder Proto \u0026  Nature of Objects"},{"content":"JavaScript is a flexible, object oriented language. This means that it allows developers to create different kinds of objects for different purposes. Almost everything in JavaScript (except Primitive types) is an object (Booleans, Strings, Numbers, Dates, Arrays, Functions, Objects, etc).\nCreating Objects Let us look at the different ways to create an object in JS.\n1. Object Literal This is the most popular and easiest way of creating objects. Object literal consists of the type of variable/object name (let, var, or const), object name, and the collection of properties inside it. Here\u0026rsquo;s an example to understand it better -\nlet obj = {}; // Object Literal A more detailed object literal -\nlet userDetails = { firstName: \u0026#39;Arya\u0026#39;, lastName: \u0026#39;Stark\u0026#39;, occupation: \u0026#39;Girl With No Name\u0026#39;, }; 2. Object Constructor Constructors are special functions that are called when an object is created with the new keyword. Take a look at the example below -\nlet person = new Object({ name: \u0026#39;Jon\u0026#39;, family: \u0026#39;Targaryen\u0026#39;, occupation: \u0026#39;Dragon Rider\u0026#39;, }); Here, the keyword new is used along with the case-sensitive keyword Object, indicating that it is a special keyword used in creating objects through Object Constructor method.\nThe result is the same as creating object through Object Literals.\n3. Object.create This is another method to create new objects, which gives us more control over handling them. Object.create accepts a parameter, which can be either null or an object (key-value pairs).\nlet user = Object.create({ name: \u0026#39;Vinoo\u0026#39;, designation: \u0026#39;Developer\u0026#39;, }); If we pass null as the parameter, it still creates an empty object.\nThe this keyword In simple words, this is a special predefined variable that is present in every function declaration. The value of this variable changes according to the way we call the function in which it is defined.\nthis is used in both global and function contexts. It always points to an object. More specifically, this references the object that is currently calling the function.\nExample -\nconst add5 = { a: 10; addition: function() { return this.a = this.a + 5; } }; add5.addition(); Here, addition() is a function which is a property of the add5 object (a function inside a property becomes a method). Hence, inside the addition() method, this references the add5 object.\nWhenever we call a function through an object ( e.g -add5.addition()), this will always point to that object.\nIn Global context, this refers to the global object, which is the window object in a web browser.\nIf we run the following snippet, it can be seen thatthis points to the window global object -\nconsole.log(this === window); //true Essentially, if a property is assigned to this, then that property is added to the global object, and can be accessed by the window object.\nExample -\nthis.value = 21; console.log(window.value); The output will be 21.\nthis keyword has more use cases in the Function context, which we shall see in an upcoming post.\nStay tuned! ðŸš€\n","permalink":"http://vinoo.in/blog/oops-in-javascript/","summary":"JavaScript is a flexible, object oriented language. This means that it allows developers to create different kinds of objects for different purposes. Almost everything in JavaScript (except Primitive types) is an object (Booleans, Strings, Numbers, Dates, Arrays, Functions, Objects, etc).\nCreating Objects Let us look at the different ways to create an object in JS.\n1. Object Literal This is the most popular and easiest way of creating objects. Object literal consists of the type of variable/object name (let, var, or const), object name, and the collection of properties inside it.","title":"OOPs in JavaScript - Creating Objects And 'this' Keyword"},{"content":"A simple Random Background Generator App built using HTML, CSS, JavaScript. Concepts of DOM manipulation and corresponding functions are implemented.\nðŸ‘‰ Live ðŸ‘‰ GitHub ","permalink":"http://vinoo.in/projects/bg-generator/","summary":"A simple Random Background Generator App built using HTML, CSS, JavaScript. Concepts of DOM manipulation and corresponding functions are implemented.\nðŸ‘‰ Live ðŸ‘‰ GitHub ","title":"Background Generator"},{"content":"The History There are cults.Â There are followers.Â And then, there is an entire world embroiled in JavaScript. A world full of engineers, developers, and designersâ€Š-â€Šall ardently worshipping a language that has taken the web world by storm. Again and again.\nJS was introduced to the world 26 years ago. I was introduced to it 9 years ago in a college classroom, and I felt.. nothing. It was taught as just another programming language, with almost the same syntax as the couple of other languages I knew, and to perform the familiar operations of \u0026ldquo;finding prime numbers\u0026rdquo;, \u0026ldquo;generating Fibonacci sequence\u0026rdquo;, etc. I learned the \u0026ldquo;how\u0026rdquo; but never the \u0026ldquo;what\u0026rdquo; or \u0026ldquo;why\u0026rdquo; of JS.Â I admit, rather embarrassingly, that back then I did not even know that JS was a language that was developed for the web. Ignorance is NOT bliss ðŸ˜.\nIt was originally created for a browser called Netscape Navigator which was competing with Internet Explorer in 1995-1996 to take over the browser domain. Eventually, Internet Explorer won the battle and became the dominant browser at large (back then).Â I know right? IE, of all browsers. Yikes!\nJS slowly evolved to become a higher end programming language that could breathe interactivity to the browser world, and thus began its many avatars to come.\nAs popularity for JS started growing, ECMA (European Computer Manufacturers Association) was handed over the responsibility of overseeing JS\u0026rsquo; development, restructuring, and maintenance. The name was changed from JavaScript to ECMAScript, but the former name has remained attached to the language to this day.\nThe Present Undeniably, JS has taken over the world of web as the main language, arguably beating its competitors by a huge factor. Gone are the days when it was only used for just interactivity. Today, we have a plethora of libraries and frameworks that have helped create an entire ecosystem around JS.\nSuch is the capability and demand that the masses and the indie hackers no less than revere this language for the intuitive, sleek, and nearly flawless experience the web provides today. All hail JavaScript.\nThe Learning After years of forgetting the language and its fundamentals, I started my journey into the world of web development, this time with renewed processes. I now understand the fundamentals in a clearer manner. This post will cover a few of the fundamentals, and the next series of posts will document my learning journey as I tackle the web world with JS.Â Let\u0026rsquo;s dive in!\nNote: This post is not a comprehensive one, nor explains the underlying concepts. This is, as the title suggests, a collection of snippets to refer to as a documentation in times of \u0026ldquo;developer perilðŸ˜¶\u0026rdquo;.\nSay Hello The first order of things while learning a new language (or relearning for that matter), is to say Hello to the World. It\u0026rsquo;s a time tested tradition for all newbies. However, considering JS is a whole other world (universe?) in itself, let\u0026rsquo;s greet it instead!\nalert() is a utility function that is essentially used to display a message in the browser. We shall come back to this later.\nAnother nifty little operator that is helpful is typeof(). It is used to identify the data type of a particular expression or variable in use.\nIn the above example, the variable a holds a value of 23. When we test with the typeof() operator, the value is identified as a number.\nValue Types There are 2 types of value types in JS.\nPrimitive Value Types These are types that can collect / hold only one value. There are 5 Primitive types:\nNumberâ€Š-â€ŠA number type is any integer or whole number, including decimals. Examples: 44, -67, 41.67844, 3.1417258, 0.56\nStringâ€Š- String type consists of letters and words encased in any of these quotes:\nBooleanâ€Š-â€ŠBoolean data type is a function that can have only one of two values. These are binary in nature. Examples: true or false, 0 or 1, ON or OFF\nUndefinedâ€Š-â€ŠUndefined is a type that indicates that the variable in question is either not assigned a value or is not declared. This is better illustrated below -\nIn the example above, we see that when we declare variable a, the status is undefined since there is no assigned value. When we check for the type of this undefined variable, the value returned is \u0026ldquo;undefined\u0026rdquo;, which is the primitive value of undefined.\nNullâ€Š-â€ŠMuch like undefined, null is also a type that indicates the absence of any value to a variable. However, unlike undefined, null does not have a value \u0026ldquo;type\u0026rdquo; to return. When tested for its type in the console, it returns the type as \u0026ldquo;object\u0026rdquo; which is what it is treated as while calling objects that are often not relevant. Non-Primitive Value Type object - This is collection of different values of different data types in a single variable. The syntax is as follows - As can be seen above, the values for the variable userDetails are enclosed in curly brackets. The values themselves are stored in what is known as key-value pairs. Here, userName is a key and \u0026ldquo;Vinoo\u0026rdquo; its corresponding value. Together, they are a key-value pair. Same goes with the userID value as well. In the image below, we can see that the console shows the result for the typeof value of userDetails as \u0026ldquo;object\u0026rdquo; data type.\nThis concludes the JS In Snippets post. Thanks for reading, and stay tuned for more articles on JavaScript. Keep Shipping!\n","permalink":"http://vinoo.in/blog/javascript-in-snippets-intro-fundamentals/","summary":"The History There are cults.Â There are followers.Â And then, there is an entire world embroiled in JavaScript. A world full of engineers, developers, and designersâ€Š-â€Šall ardently worshipping a language that has taken the web world by storm. Again and again.\nJS was introduced to the world 26 years ago. I was introduced to it 9 years ago in a college classroom, and I felt.. nothing. It was taught as just another programming language, with almost the same syntax as the couple of other languages I knew, and to perform the familiar operations of \u0026ldquo;finding prime numbers\u0026rdquo;, \u0026ldquo;generating Fibonacci sequence\u0026rdquo;, etc.","title":"Javascript in Snippets: Intro and Fundamentals"}]